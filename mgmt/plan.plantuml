@startuml

database Aurora_M
database Aurora_S
database TiDB_M
database TiDB_S

TiDB_M <-- Aurora_M: binlog to
Aurora_M --> Aurora_S : binlog to
TiDB_M --> TiDB_S: binlog to

[sync-diff by pingcap] as sdp
[JSON-SD] as sd

sd --> Aurora_S
sd --> TiDB_S

sdp --> TiDB_M: optional
sdp --> TiDB_S: optional


@enduml


@startuml

database Aurora_M
database Aurora_S
database TiDB_M

TiDB_M <-- Aurora_M: binlog to
Aurora_M --> Aurora_S : binlog to

[sync-diff] as sd

sd --> Aurora_S
sd --> TiDB_M


@enduml


@startuml

database Aurora_M
database Aurora_S
database TiDB_M
database Wallet

[cross domain checker] as dc
[sync-diff] as sd
[payment] as pay

pay --> Aurora_M
TiDB_M <-- Aurora_M: binlog to
Aurora_M --> Aurora_S : existing binlog to

dc --> TiDB_M
dc --> Wallet

sd --> TiDB_M
sd --> Aurora_S

@enduml


@startuml

component [Pre-prod] {
database TiDB
queue "saved mysql traffic" as traffic 
[sync-diff] as sd
database Aurora_V
[cross domain checking] as cd
}

component [PROD] {
[payment] as srv
database wallet_s
}


srv --> traffic
traffic --> Aurora_V
traffic --> TiDB

sd --> TiDB

sd --> Aurora_V
@enduml

@startuml

component [PROD]{
database Aurora_M
database Aurora_S
database TiDB_M
database TiDB_S
component Payment
database Wallet
}

component [PRE-PROD]{

queue ReplayProxy as rp
database TiDB_V
[cross domain checker] as dc
[sync-diff] as sd
}


TiDB_M <-- Aurora_M: binlog to
TiDB_M --> TiDB_S: binlog to
Aurora_M --> Aurora_S : existing binlog to
Aurora_S -> Daas: exisiting pipeline to
Payment --> rp
rp --> Aurora_M: RW
rp --> TiDB_V: RW

dc --> TiDB_V
dc --> Wallet

sd --> TiDB_V
sd --> Aurora_S

@enduml


@startuml

database RDS {
    [topup]
    [others]
}
database TiDB {
    "topup" as [T-topup]
    "others" as [T-others]
}


request --> [payment]
component [payment] {
    component [sharding-proxy]
}
[sharding-proxy] --> [T-others]
[sharding-proxy] --> [T-topup]

[T-topup] --> [topup]: replication
[T-others] --> [others]: replication

@enduml
@startuml
database "aurora" {
  [payment_p2p]
  [subpayment_p2p]
  [tranfer_p2p]
  [payment_other]
  [subpayment_other]
  [payment_acq]
  [subpayment_acq]
  [payment_topup]
  [subpayment_topup]
  [other tables....]
}
database tidb
aurora --> tidb: binlog all tables
@enduml


@startuml
database TiDB_M
database TiDB_S
database Aurora_M
database Aurora_S
database Wallet_S

TiDB_M --> Aurora_M: binlog to
TiDB_M --> TiDB_S: binlog to
Aurora_M --> Aurora_S : existing binlog to
Aurora_S -> Daas: exisiting pipeline to
[Payment] --> TiDB_M: RW
[Domain checker] --> Wallet_S: R
[Domain checker] --> TiDB_M: RW
@enduml

database Wallet_S
[DB checker] --> Aurora_S: R
[DB checker] --> TiDB_M: RW
[Domain checker] --> TiDB_M: RW
[Domain checker] --> Wallet_S: R
[Verifier] --> TiDB_V: RW
[Verifier] --> Wallet_S: R
[Verifier] --> Aurora_S: R



@startuml
database TiDB
database Aurora_M as RDS
database Aurora_S as Slave
component [cashier] as C {
    [proxy]
}
component [NPS] as P
queue kafka
[/pay] -> C
proxy --> [OPS]: 99% /pay
proxy --> P: 1% /pay
[OPS] -> RDS
P --> TiDB
TiDB --> RDS: binlog
[other APIs] --> [NRS]
kafka --> [NRS]
[NRS] -> RDS
[NRS] -> TiDB
RDS -> Slave: existing binlog
Slave -> [DaaS]: existing pipeline
@enduml

@startuml
database TiDB_M
database TiDB_S
database Aurora_M
database Aurora_S

TiDB_M --> Aurora_M: binlog
TiDB_M -> TiDB_S: binlog
Aurora_M -> Aurora_S : existing binlog
Aurora_S -> Daas: exisiting pipeline

[Payment] -> TiDB_M
@enduml



@startuml
skinparam component {
	backgroundColor<<done>> Green
	backgroundColor<<doing>> Yellow
	backgroundColor<<explore>> Blue
}

[Java] --> [Spring]
[Network] --> [RDS]
[Network] --> [Redis]
[RDS] --> [Spring]
[Java] --> [Kafka]
[Network] --> [Kafka]
@enduml
