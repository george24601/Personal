@startuml

database "recon" {
  [channel_coupon] as meta
}

queue "budget control alerts" as bca
queue "pai.gm.clm.coupon" as clm
queue "pai.gm.clm.coupon" as clm
queue "pai.gm.mcms.coupon" as mcms
queue "pai.gm.mcms.date.resolve" as sn

[merchant notification scanner] as mns
mns --> mcms : src
mns --> bca :src
mns --> clm :sink
mns --> sn : sink
mns --> recon
@enduml

@startuml
database "notification" {
  [channel_coupon] as coupon
  [customer_coupon] as uc
  [user_status] as status
  [merchant_status] as ms
}

queue "budget control alerts" as bca
queue "MCMS - coupon state change" as cs
queue "Coupon wallet - user action" as ua
queue "customer sink" as sink
queue "merchant sink" as merchant_sink
[coupon state capture] as csc
csc --> coupon
csc --> cs
[user coupon action capture] as ucac
ucac --> uc
ucac --> ua
[user notification scanner] as ns
ns --> coupon
ns --> uc 
ns --> sink
ns --> status

[merchant notification scanner] as mns
mns --> ms
mns --> coupon
mns --> merchant_sink
mns --> bca

@enduml


@startuml
database redis {
[128 zsets to store events] as data
}

[dispatcher] as p
[consumer] as c

[upstream pods] as upstream

[optional demultiplexer] as demul
queue "effectve topic per event" as etpe

queue "multiplexed segment match topic" as uet
queue "multiplexed effective event" as eet
queue "dispatcher dlq" as dd
queue "consumer dlq" as cd

uet <-- p
p --> dd
p --> eet
p --> data
upstream --> uet
eet <-- demul
demul --> etpe

c --> data
c -->cd
c --> eet
@enduml


