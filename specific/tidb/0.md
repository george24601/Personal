Split by KV range: has NOTHING to do with table partitioning

Data is tagged with versions: key_version:value

lock-free snapshot read: change to snapshot version,i.e., lock free

Percolator based txn: almost decentralized 2PC. single point failure is the timestamp allocation. 

isolation: snapshot isolation

layered tikv: txn -> MVCC -> raftkv -> local kv (rocks db)

PD: placement driver, itself a 3 replica cluster

Admin can inject config into PD

Row: key -> table id + row id, value: row value
index: table id + index id + index-column-value, value: rowid (non-unique, goes rowid will go to the index)
encoding should preserve order

every mysql master can use a syncer to aggregate into the same tidb cluster (e.g., sharded db)

tidb binlog: backup in real time
dumper + loader for full backup restore => tidb-lighting: 1T data in 6 hours ingestion

at most 512 columns in a single table 

### optimize queries
ANALYZE TABLE
EXPLAIN
USE INDEX, FORCE INDEX, IGNORE INDEX

2pc problem with transaction manager HA

PD/TiKV/TiDB control

LB in front of tidb servers

10 mins to gc expired MVCC

grafana port at 3000: lock resolve OPS : txn conflict

PD TSO: often bottleneck

one tikv node with multiple stores , each mapped to 1 harddrive

pd harder to scale up/down

SI is roughly as RR

1 index, 1 kv entry => more kv, more storage

turn params to improve sql performance

best virtualization gives 30% penalty over physical machine

keep synclog-log = true

PD= 5 copies
tikv=5 copies
every instance on a separate disk

1000 mysql, 1000 syncher?
