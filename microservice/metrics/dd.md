Tags are converted to lowercase.

For optimal functionality, we recommend constructing tags that use the key:value syntax.

device, host, and source are reserved tag keys and cannot be specified in the standard way
You can also enter tags: followed by a tag to see all the events that come from a host or integration with that tag. The example in the image is the tag role:cassandra. So the search text is tags:role:cassandra

A custom metric refers to a single, unique combination of a metric name, host, and any tags.

Note that the ordering of tags does not matter

The format for sending metrics is metric.name:value|type|@sample_rate|#tag1:value,tag2,

Metric types: 

1. Gauges:  value of a particular thing over time. If called multiple times during a check’s execution for a metric only the last sample is used.

2. Rate: it’s the value variation of a metric on a defined time interval.Submit the sampled raw value of your counter. Don’t normalize the values to a rate, or calculate the deltas before submitting - the Agent does both for you. Should only be called once during a check.
Throws away any value that is less than a previously submitted value. IE the counter should be monotonically increasing.
Stored as a GAUGE type in the Datadog web application. Each value in the stored timeseries is a time-normalized delta of the counter’s value between samples.

#spring cloud integration

Through, MeterRegistryCustomizer, you can customize the whole set of registries at once or individual implementations in particular. For example, a commonly requested setup is to (1) export metrics to both Prometheus and CloudWatch, (2) add a set of common tags to metrics flowing to both (for example, host and application identifying tags) and (3) whitelist only a small subset of metrics to CloudWatch.

#k8s

Now Kubernetes, which orchestrates your containers, also needs to be monitored in order to track your infrastructure at a high level. That makes 4 different components that now need to be monitored, each with their specificities and challenges:

Your hosts, even if you don’t know which containers and applications they are actually running
Your containers
Your containerized applications
Kubernetes itself

k8s-state-metrics is not focused on the health of the individual Kubernetes components, but rather on the health of the various objects inside, such as deployments, nodes and pods.

The metrics are exported through the Prometheus golang client on the HTTP endpoint /metrics on the listening port (default 80). They are served either as plaintext or protobuf depending on the Accept header. They are designed to be consumed either by Prometheus itself or by a scraper that is compatible with scraping a Prometheus client endpoint. You can also open /metrics in a browser to see the raw metrics.

We cannot talk about Kubernetes metrics without introducing Heapster: it is for now the go-to source for basic resource utilization metrics and events from your Kubernetes clusters. On each node, cAdvisor collects data about running containers that Heapster then queries through the kubelet of the node

As mentioned above, Kubernetes relies on Heapster to report metrics instead of the cgroup file directly. And one of Heapster’s limitations is that it collects Kubernetes metrics at a different frequency (aka “housekeeping interval”) than cAdvisor, which makes the overall metric collection frequency for metrics reported by Heapster tricky to evaluate.

That’s why you should really consider tracking metrics from your containers instead of from Kubernetes.

monitoring the sum of requests (limits?) on the node and making sure it never exceeds your node’s capacity is much more important than monitoring simple CPU or memory usage.

kube-state-metrics is a service that provides additional metrics that Heapster does not. Heapster exposes metrics about the resource utilization of components such as CPU, memory, or network. kube-state-metrics, on the other hand, listens to the Kubernetes API and generates metrics about the state of Kubernetes logical objects: node status, node capacity (CPU and memory), number of desired/available/unavailable/updated replicas per deployment, pod status (e.g. waiting, running, ready), and so on.

Note that the way it works under the hood is different from Heapster, which is only an intermediary that reformats and exposes metrics already generated by Kubernetes, whereas kube-state-metrics generates the metrics itself.
