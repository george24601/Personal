#!/bin/bash

#takes at 5 mins to start!
#The --vm-driver=hyperkit flag specifies that you are using Docker for Mac
minikube start --vm-driver=hyperkit

#The context is what determines which cluster kubectl is interacting with.
kubectl config use-context minikube

#open dashboard
minikube dashboard

eval $(minikube docker-env)

docker build -t hello-node:v1 .

#run command creates a new deployment
kubectl run hello-node --image=hello-node:v1 --port=8080 --image-pull-policy=Never

kubectl expose deployment hello-node --type=LoadBalancer

#on local, use this to check - will popup browser
#equivalent to curl $(minikube ip):$NODE_PORT
minikube service hello-node

##t2
#can create a proxy that will forward communications into the cluster-wide, private network,i.e., on localhost 
kubectl proxy

export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')

export POD_NAME=hello-node-57c6b66f9c-cvmpt

echo $POD_NAME

#this one will hit our actual port directly!
curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/

#execute commands directly on the container once the Pod is up and running
kubectl exec -ti $POD_NAME bash


##rolling upgrade, followed by the deployment name and the new image version
kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2

#undo the rollout
kubectl rollout undo deployments/kubernetes-bootcamp

#checkout rollout status
kubectl rollout status deployments/kubernetes-bootcamp


##ConfigMap setup
kubectl create configmap example-redis-config --from-file=https://k8s.io/examples/pods/config/redis-config
kubectl get configmap example-redis-config -o yaml


