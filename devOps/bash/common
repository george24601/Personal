#!/bin/bash


#delete the folder if it exists, note that the spaces around -d predicate matter! 
[ -d $FOLDER ] && rm -r $FOLDER

#But -d does not work with wildcards!
if ls /path/to/your/files* 1> /dev/null 2>&1; then
      echo "files do exist"

#compress and decompress, -c compress, -x extract
tar -czvf $TO.tar.gz $FROM

#display error code of the last command,e.g., use it after a semicolon 
echo $?
#similarly, !$ is the last argument of the previous command
cd !$

#use of CDPATH, probably what to edit your ~/.bashrc

#automatically corrects small typos in directory names and jumps to the best guess of existing directories.
shopt -s cdspell

#shell to exit if any subcommand or pipeline returns a non-zero status
set -e

#multiline to a single line
cat file.txt|xargs

#single to multilines
cat single.txt | xargs -n 3
#replace tab with space
tr '\t' ' '

#delete all digits
tr -d '0-9'

#remove duplicate spaces
cat file | tr -s ' '

#cut 2nd and 4th column
cut -f2,4 file

#get all but 3rd column
cut -f3 --complement file

#search only files with certain extensions
grep -r --include=*.scala 'spray' ./ | less

#record terminal output
script my.terminal.seeesion

#creating a new environment without any existing environment variables for a new shell
env -i /bin/sh

#Note that this use of env is often unnecessary since most shells support setting environment variables in front of a command
env DISPLAY=foo.bar:1.0 xcalc

#take out --decode to encode
base64 --decode ${FILE_PATH}

#list open files in the open space
lsof -P -n | wc -l

# -n to not append the extra newline, use --decode after base64 to decode
echo -n ${DD_KEY} | base64 

#It’s similar to $() in that the output of the command inside is re-used. In this case, though, the output is treated as a file. This file can be used as an argument to commands that take files as an argument.
diff <(grep somestring file1) <(grep somestring file2)

#!$ repeats the last argument of the last command

#!:1-$ It takes all the arguments to the previous command and drops them in.

#default value for variables
#You can also assign directly with ${VAR:=defaultval} (equals sign, not dash) but note that this won’t work with positional variables in scripts or functions.
THIRD_ARG="${3:-no_third_arg}"


